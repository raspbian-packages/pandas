Description: Remove code from Stack Overflow

Stack Overflow content is CC-BY-SA licensed,
which this package is not supposed to be.  These snippets may be
too small to be copyrightable, but removing them to be safe.

https://lists.debian.org/debian-legal/2020/04/threads.html#00018

Author: Rebecca N. Palmer <rebecca_palmer@zoho.com>
Forwarded: no - deletes some tests/examples without replacement

--- /dev/null
+++ b/doc/source/user_guide/cookbook.rst
@@ -0,0 +1,22 @@
+.. _cookbook:
+
+{{ header }}
+
+.. _cookbook.idioms:
+.. _cookbook.selection:
+.. _cookbook.multi_index:
+.. _cookbook.missing_data:
+.. _cookbook.grouping:
+.. _cookbook.pivot:
+.. _cookbook.resample:
+.. _cookbook.merge:
+.. _cookbook.plotting:
+.. _cookbook.csv:
+.. _cookbook.csv.multiple_files:
+.. _cookbook.sql:
+.. _cookbook.excel:
+.. _cookbook.html:
+.. _cookbook.hdf:
+.. _cookbook.binary:
+
+This page has been removed for copyright reasons.
--- a/doc/source/user_guide/index.rst
+++ b/doc/source/user_guide/index.rst
@@ -47,4 +47,3 @@ Further information on any specific meth
     scale
     sparse
     gotchas
-    cookbook
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -1491,14 +1491,14 @@ def _get_valid_sqlite_name(name):
     # Replace all " with "".
     # Wrap the entire thing in double quotes.
 
-    uname = _get_unicode_name(name)
-    if not len(uname):
+    name = _get_unicode_name(name)
+    if not len(name):
         raise ValueError("Empty table or column name specified")
 
-    nul_index = uname.find("\x00")
-    if nul_index >= 0:
+    if '\0' in name:
         raise ValueError("SQLite identifier cannot contain NULs")
-    return '"' + uname.replace('"', '""') + '"'
+    name = name.replace('"', '""')
+    return '"' + name + '"'
 
 
 _SAFE_NAMES_WARNING = (
--- a/pandas/tests/groupby/aggregate/test_other.py
+++ b/pandas/tests/groupby/aggregate/test_other.py
@@ -24,30 +24,6 @@ from pandas.core.base import Specificati
 from pandas.io.formats.printing import pprint_thing
 
 
-def test_agg_api():
-    # GH 6337
-    # https://stackoverflow.com/questions/21706030/pandas-groupby-agg-function-column-dtype-error
-    # different api for agg when passed custom function with mixed frame
-
-    df = DataFrame(
-        {
-            "data1": np.random.randn(5),
-            "data2": np.random.randn(5),
-            "key1": ["a", "a", "b", "b", "a"],
-            "key2": ["one", "two", "one", "two", "one"],
-        }
-    )
-    grouped = df.groupby("key1")
-
-    def peak_to_peak(arr):
-        return arr.max() - arr.min()
-
-    expected = grouped.agg([peak_to_peak])
-    expected.columns = ["data1", "data2"]
-    result = grouped.agg(peak_to_peak)
-    tm.assert_frame_equal(result, expected)
-
-
 def test_agg_datetimes_mixed():
     data = [[1, "2012-01-01", 1.0], [2, "2012-01-02", 2.0], [3, None, 3.0]]
 
--- a/pandas/tests/groupby/test_categorical.py
+++ b/pandas/tests/groupby/test_categorical.py
@@ -837,29 +837,6 @@ def test_groupby_empty_with_category():
     tm.assert_series_equal(result, expected)
 
 
-def test_sort():
-
-    # https://stackoverflow.com/questions/23814368/sorting-pandas-
-    #        categorical-labels-after-groupby
-    # This should result in a properly sorted Series so that the plot
-    # has a sorted x axis
-    # self.cat.groupby(['value_group'])['value_group'].count().plot(kind='bar')
-
-    df = DataFrame({"value": np.random.randint(0, 10000, 100)})
-    labels = [f"{i} - {i+499}" for i in range(0, 10000, 500)]
-    cat_labels = Categorical(labels, labels)
-
-    df = df.sort_values(by=["value"], ascending=True)
-    df["value_group"] = pd.cut(
-        df.value, range(0, 10500, 500), right=False, labels=cat_labels
-    )
-
-    res = df.groupby(["value_group"], observed=False)["value_group"].count()
-    exp = res[sorted(res.index, key=lambda x: float(x.split()[0]))]
-    exp.index = CategoricalIndex(exp.index, name=exp.index.name)
-    tm.assert_series_equal(res, exp)
-
-
 def test_sort2():
     # dataframe groupby sort was being ignored # GH 8868
     df = DataFrame(
--- a/pandas/tests/indexing/multiindex/test_chaining_and_caching.py
+++ b/pandas/tests/indexing/multiindex/test_chaining_and_caching.py
@@ -6,28 +6,6 @@ import pandas._testing as tm
 import pandas.core.common as com
 
 
-def test_detect_chained_assignment():
-    # Inplace ops, originally from:
-    # https://stackoverflow.com/questions/20508968/series-fillna-in-a-multiindex-dataframe-does-not-fill-is-this-a-bug
-    a = [12, 23]
-    b = [123, None]
-    c = [1234, 2345]
-    d = [12345, 23456]
-    tuples = [("eyes", "left"), ("eyes", "right"), ("ears", "left"), ("ears", "right")]
-    events = {
-        ("eyes", "left"): a,
-        ("eyes", "right"): b,
-        ("ears", "left"): c,
-        ("ears", "right"): d,
-    }
-    multiind = MultiIndex.from_tuples(tuples, names=["part", "side"])
-    zed = DataFrame(events, index=["a", "b"], columns=multiind)
-
-    msg = "A value is trying to be set on a copy of a slice from a DataFrame"
-    with pytest.raises(com.SettingWithCopyError, match=msg):
-        zed["eyes"]["right"].fillna(value=555, inplace=True)
-
-
 def test_cache_updating():
     # 5216
     # make sure that we don't try to set a dead cache
--- a/pandas/tests/indexing/multiindex/test_setitem.py
+++ b/pandas/tests/indexing/multiindex/test_setitem.py
@@ -141,35 +141,7 @@ class TestMultiIndexSetItem:
         with pytest.raises(TypeError, match=msg):
             df.loc["bar"] *= 2
 
-        # from SO
-        # https://stackoverflow.com/questions/24572040/pandas-access-the-level-of-multiindex-for-inplace-operation
-        df_orig = DataFrame.from_dict(
-            {
-                "price": {
-                    ("DE", "Coal", "Stock"): 2,
-                    ("DE", "Gas", "Stock"): 4,
-                    ("DE", "Elec", "Demand"): 1,
-                    ("FR", "Gas", "Stock"): 5,
-                    ("FR", "Solar", "SupIm"): 0,
-                    ("FR", "Wind", "SupIm"): 0,
-                }
-            }
-        )
-        df_orig.index = MultiIndex.from_tuples(
-            df_orig.index, names=["Sit", "Com", "Type"]
-        )
 
-        expected = df_orig.copy()
-        expected.iloc[[0, 2, 3]] *= 2
-
-        idx = pd.IndexSlice
-        df = df_orig.copy()
-        df.loc[idx[:, :, "Stock"], :] *= 2
-        tm.assert_frame_equal(df, expected)
-
-        df = df_orig.copy()
-        df.loc[idx[:, :, "Stock"], "price"] *= 2
-        tm.assert_frame_equal(df, expected)
 
     def test_multiindex_assignment(self):
 
--- a/pandas/tests/indexing/test_chaining_and_caching.py
+++ b/pandas/tests/indexing/test_chaining_and_caching.py
@@ -287,14 +287,6 @@ class TestChaining:
         df["column1"] = df["column1"] + "c"
         str(df)
 
-        # from SO:
-        # https://stackoverflow.com/questions/24054495/potential-bug-setting-value-for-undefined-column-using-iloc
-        df = DataFrame(np.arange(0, 9), columns=["count"])
-        df["group"] = "b"
-
-        with pytest.raises(com.SettingWithCopyError):
-            df.iloc[0:5]["group"] = "a"
-
         # Mixed type setting but same dtype & changing dtype
         df = DataFrame(
             dict(
--- a/pandas/tests/io/parser/test_common.py
+++ b/pandas/tests/io/parser/test_common.py
@@ -1077,24 +1077,6 @@ def test_trailing_delimiters(all_parsers
     tm.assert_frame_equal(result, expected)
 
 
-def test_escapechar(all_parsers):
-    # https://stackoverflow.com/questions/13824840/feature-request-for-
-    # pandas-read-csv
-    data = '''SEARCH_TERM,ACTUAL_URL
-"bra tv bord","http://www.ikea.com/se/sv/catalog/categories/departments/living_room/10475/?se%7cps%7cnonbranded%7cvardagsrum%7cgoogle%7ctv_bord"
-"tv p\xc3\xa5 hjul","http://www.ikea.com/se/sv/catalog/categories/departments/living_room/10475/?se%7cps%7cnonbranded%7cvardagsrum%7cgoogle%7ctv_bord"
-"SLAGBORD, \\"Bergslagen\\", IKEA:s 1700-tals series","http://www.ikea.com/se/sv/catalog/categories/departments/living_room/10475/?se%7cps%7cnonbranded%7cvardagsrum%7cgoogle%7ctv_bord"'''  # noqa
-
-    parser = all_parsers
-    result = parser.read_csv(
-        StringIO(data), escapechar="\\", quotechar='"', encoding="utf-8"
-    )
-
-    assert result["SEARCH_TERM"][2] == 'SLAGBORD, "Bergslagen", IKEA:s 1700-tals series'
-
-    tm.assert_index_equal(result.columns, Index(["SEARCH_TERM", "ACTUAL_URL"]))
-
-
 def test_int64_min_issues(all_parsers):
     # see gh-2599
     parser = all_parsers
