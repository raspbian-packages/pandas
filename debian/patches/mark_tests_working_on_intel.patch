Description: Mark those tests @pytest.mark.intel that pass only on Intel architectures
Author: Andreas Tille <tille@debian.org>
Last-Update Sat, 14 Oct 2017 19:42:59 +0200
Bug-Debian: https://bugs.debian.org/877419
Author: Graham Inggs <ginggs@debian.org>
Last-Update: 2018-04-11

--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -688,6 +688,7 @@
             expected = Series([2, 1, 1], index=[5., 10.3, np.nan])
             tm.assert_series_equal(result, expected)
 
+    @pytest.mark.intel
     def test_value_counts_normalized(self):
         # GH12558
         s = Series([1, 2, np.nan, np.nan, np.nan])
--- a/pandas/tests/test_resample.py
+++ b/pandas/tests/test_resample.py
@@ -2204,6 +2204,7 @@
 
         assert_frame_equal(frame.resample('60s').mean(), frame_3s)
 
+    @pytest.mark.intel
     def test_resample_timedelta_values(self):
         # GH 13119
         # check that timedelta dtype is preserved when NaT values are
@@ -2221,6 +2222,7 @@
         res = df['time'].resample('2D').first()
         tm.assert_series_equal(res, exp)
 
+    @pytest.mark.intel
     def test_resample_datetime_values(self):
         # GH 13119
         # check that datetime dtype is preserved when NaT values are
--- a/pandas/tests/dtypes/test_cast.py
+++ b/pandas/tests/dtypes/test_cast.py
@@ -78,6 +78,7 @@
             tm.assert_almost_equal(result, np.array([], dtype=np.int64))
             assert result.dtype == np.int64
 
+    @pytest.mark.intel
     def test_datetimelikes_nan(self):
         arr = np.array([1, 2, np.nan])
         exp = np.array([1, 2, np.datetime64('NaT')], dtype='datetime64[ns]')
--- a/pandas/tests/frame/test_indexing.py
+++ b/pandas/tests/frame/test_indexing.py
@@ -2649,6 +2649,7 @@
         result = a.where(do_not_replace, b)
         assert_frame_equal(result, expected)
 
+    @pytest.mark.intel
     def test_where_datetime(self):
 
         # GH 3311
--- a/pandas/tests/frame/test_operators.py
+++ b/pandas/tests/frame/test_operators.py
@@ -177,6 +177,7 @@
             df)), 'b': date_range('20100101', periods=len(df))})
         check(df, df2)
 
+    @pytest.mark.intel
     def test_timestamp_compare(self):
         # make sure we can compare Timestamps on the right AND left hand side
         # GH4982
--- a/pandas/tests/groupby/test_aggregate.py
+++ b/pandas/tests/groupby/test_aggregate.py
@@ -131,6 +131,7 @@
         grouped = df.groupby(df.index.month)
         list(grouped)
 
+    @pytest.mark.intel
     def test_agg_dict_parameter_cast_result_dtypes(self):
         # GH 12821
 
--- a/pandas/tests/series/test_constructors.py
+++ b/pandas/tests/series/test_constructors.py
@@ -786,6 +786,7 @@
         series[2] = val
         assert isna(series[2])
 
+    @pytest.mark.intel
     def test_NaT_cast(self):
         # GH10747
         result = Series([np.nan]).astype('M8[ns]')
--- a/pandas/tests/series/test_period.py
+++ b/pandas/tests/series/test_period.py
@@ -94,6 +94,7 @@
         series[2] = val
         assert isna(series[2])
 
+    @pytest.mark.intel
     def test_NaT_cast(self):
         result = Series([np.nan]).astype('period[D]')
         expected = Series([NaT])
--- a/pandas/tests/frame/test_analytics.py
+++ b/pandas/tests/frame/test_analytics.py
@@ -974,6 +974,7 @@
         expected = pd.Series(result, index=['A', 'B'])
         tm.assert_series_equal(result, expected)
 
+    @pytest.mark.intel
     def test_sum_nanops_timedelta(self):
         # prod isn't defined on timedeltas
         idx = ['a', 'b', 'c']
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -1104,6 +1104,7 @@
             result = base - offset
             assert result == expected_sub
 
+    @pytest.mark.intel
     def test_timedelta_ops_with_missing_values(self):
         # setup
         s1 = pd.to_timedelta(Series(['00:00:01']))
